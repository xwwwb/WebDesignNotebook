# 笔记
## 异步编程
* fs 文件操作
```
require('fs').readFile('./index.html',(err,data)=>{})
```
* 数据库操作
* ajax
```
$.get('/server/',(data)=>{})
```
* 定时器
```
setTimeout(()=>{},2000);
```
# util.promisify方法
promisify方法可以把不是promise的方法变成promise方法
条件:
- 回调函数必须是主函数中参数位置的最后一个
- 回调函数中第一个参数必须是error

https://www.cnblogs.com/ikcamp/p/7767818.html

```javascript
// 原有的callback调用
fs.readFile('test.js', function(err, data) {
    if (!err) {
        console.log(data);
    } else {
        console.log(err);
    }
});

// promisify后
var readFileAsync = promisify(fs.readFile);
readFileAsync('test.js').then(data => {
    console.log(data);
}, err => {
    console.log(err);
});
```

## Promise的状态
实力对象中的一个属性 [PromiseState]
* pending 未决定的
* resolved / fullfiled 成功
* reject 失败

## Promise 对象的值
实例对象中的另一个属性 [PromiseResult]
保存着异步任务 [成功/失败] 的结果
* resolve
* reject

## Promise构造函数 Promise(executor){}
1. executor函数:执行器(resolve,reject)=>{}
2. resolve函数:内部定义成功时我们调用函数value=>{}
3. reject函数:内部定义失败时我们调用的函数reason=>{}
说明:executor会在promise内部立即同步调用 异步操作在执行器中执行

## Promise.prototype.then 方法(onResolved,onRejected)=>{}
1. onResolved函数: 成功的回调函数(value)=>{}
2. onRejected函数: 失败的回调函数(reason)=>{}
说明: 指定用于得到成功value的成功回调和用于得到失败reason的失败回调返回一个新的promise对象

## Promise.prototype.catch方法(onRejected)=>{}
1. onRejected函数:失败的回调函数(reason)=>{}
